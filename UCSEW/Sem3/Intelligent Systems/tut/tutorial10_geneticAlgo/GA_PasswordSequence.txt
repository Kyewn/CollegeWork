
# Dear Students, 
# This is an example to break the password sequence. Algorithm can know length of password, 
# algorithm ca ask about how good is the proposed evaluated score
# 1 point cross over 

#  For example, Score 1 point for each correct guess e.g if password is accdr then score(acppp) =2 a and c are correct

# Evaluate unit score according to rules
def evaluate(unit):
  score = 0;
  for idx, gen in enumerate(unit):
    if password[idx] == gen:
      score += 1;
  return score;
  
  
  
  #Select best subpopulation (size = range) from give population
def selectFromPopulation(population, range):
  evaluatedPopulation = list(map(evaluate, population));
  selection = [];

  for idx, value in enumerate(evaluatedPopulation):
    selection.append({
        'score': value,
        'unit': population[idx]
    })

  def getScore(dict):
    return int(dict.get('score'))

  selection.sort(key=getScore, reverse=True)
  selection = list(map(lambda dict: dict.get('unit'), selection))
  return selection[:range];
  
  
  # Generate random unit from genes pool
def randomUnit():
  unit = [];
  while len(unit) < len(password):
    randomGeneIndex = int(round(random.random() * (len(genes) - 1)));
    gene = list(genes)[randomGeneIndex]
    unit.append(gene);
  return "".join(unit)

def getRandomInitialPopulation(size):
  population = [];
  while len(population) < size:
    population.append(randomUnit())
  return population

#Crossover
def breed(unitA, unitB):
  listUnitA = list(unitA);
  listUnitB = list(unitB);
  newUnit = [];
  for idx, gene in enumerate(list(unitA)):
    if random.random() > 0.5:
      newGene = listUnitA[idx];
    else:
      newGene = listUnitB[idx];
    newUnit.append(newGene);
  return "".join(newUnit)
  
  
  

  def getRandomBreedPair(population):
  population_length = len(population);
  firstRandomIndex = int(round(random.random() * (population_length - 1)));
  secondRandomIndex = int(round(random.random() * (population_length -1)));
  while secondRandomIndex == firstRandomIndex:
   secondRandomIndex = int(round(random.random() * (population_length - 1)));
  return population[firstRandomIndex], population[secondRandomIndex]
  
  
    //Mutation
	
# Every breed have a chance got mutation on a random gene.
MUTATION_RATE = 0.05

def isMutating():
  chance = random.random();
  return chance < MUTATION_RATE
  #--------------------------------------#
  
 #Mutate random gene
def mutate(unit):
  indexToMutate = int(round(random.random() * (len(unit) - 1)))
  mutatedUnit = list(unit);
  randomMutationIndex = int(round(random.random() * (len(genes) - 1)));
  mutatedUnit[indexToMutate] = list(genes)[randomMutationIndex];
  mutatedUnit = "".join(mutatedUnit)
  return mutatedUnit

#-------------------------------------#

  #Algorithm
  # helper function avg population score;
import statistics

def avgPopulationScore(population):
  return statistics.mean(list(map(evaluate, population)))
  #--------------------------------#
  # Adjustable config
 
 you can define

# Max number of generations created
you can define

initialPopulation = getRandomInitialPopulation(POPULATION_SIZE);
selected = selectFromPopulation(initialPopulation, SELECTION_RANGE);

while current_generation < generations:
  if len(selected) < 2:
    raise NameError('population too low')

  nextPopulation = [5];
  while len(nextPopulation) < POPULATION_SIZE:
    unitA, unitB = getRandomBreedPair(selected);
    newUnit = breed(unitA, unitB);
    if isMutating():
      newUnit = mutate(newUnit);
    nextPopulation.append(newUnit)

 // your IF condition
 
 
 
  selected = selectFromPopulation(nextPopulation, SELECTION_RANGE);
  current_generation += 1;
  if len(password) in list(map(evaluate, selected)):
    print('We got this: {0}'.format(selected[0]))
    break


print(selected[0]);
print(list(map(evaluate, selected)))
